# Лабораторная работа 9-10. Алгоритмы. Работа с алгоритмами сортировки и поиска.
## README.md - Аналитическая часть
### Алгоритмы сортировки:

#### 1. Блочная (корзинная) сортировка (Bucket Sort)

Определение:
Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Объяснение работы алгоритма:
1. Определяется количество корзин и функция распределения.
2. Каждый элемент попадает в свою корзину.
3. Корзины сортируются (обычно сортировкой вставками).
4. Корзины объединяются.

Оценка временной сложности алгоритма в нотации Big(O):
Лучший/средний случай: O(n + k)
Худший случай: O(n²)

Краткое объяснение оценки временной сложности алгоритма соответственно представленной нотации Big(O):
При равномерном распределении элементов сортировка почти линейна. В худшем случае все элементы попадают в одну корзину, и сложность зависит от алгоритма сортировки внутри корзины.

#### 2. Блинная сортировка (Pancake Sort).

Определение:
 Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.

Объяснение работы алгоритма:
1. Найти максимальный элемент в неотсортированной части.
2. Перевернуть подмассив до позиции максимального элемента.
3. Перевернуть подмассив длиной текущей неотсортированной части.
4. Повторить, пока массив не будет отсортирован.

Оценка временной сложности алгоритма в нотации Big(O):
O(n²)

Краткое объяснение оценки временной сложности алгоритма соответственно представленной нотации Big(O):
На каждом шаге ищется максимум (O(n)) и выполняются перевороты (O(n)), итого O(n²).

#### 3. Сортировка бусинами (Bead/Gravity Sort)

Определение:
Сортировка бусинами (Bead Sort) моделирует падение бусин под действием гравитации. 
Используется для сортировки неотрицательных целых чисел.

Объяснение работы алгоритма:
1. Каждый элемент представлен как ряд бусин.
2. Бусины размещаются в колонках.
3. Под действием гравитации они оседают вниз.
4. Считывается результат — отсортированный массив.

Оценка временной сложности алгоритма в нотации Big(O):
O(n * m), где m — максимальное значение элемента.

Краткое объяснение оценки временной сложности алгоритма соответственно представленной нотации Big(O):
Создаётся двумерная структура размером n×m, что делает алгоритм неэффективным для больших чисел.



### Алгоритмы поиска:

#### 4. Поиск скачками (Jump Search)

Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

Объяснение работы алгоритма:
1. Массив делится на блоки длины m=n.
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому.
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке.

Оценка временной сложности алгоритма в нотации Big(O):
O(√n)

Краткое объяснение оценки временной сложности алгоритма соответственно представленной нотации Big(O):
Сложность — сумма прыжков и линейного поиска: n/m + m, минимум достигается при m ≈ √n.

#### 5. Экспоненциальный поиск (Exponential Search)

Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Объяснение работы алгоритма:
1. Проверяется первый элемент массива.
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д.,
пока не будет найден элемент, больше или равный искомому.
3. На найденном диапазоне выполняется бинарный поиск.

Оценка временной сложности алгоритма в нотации Big(O):
O(log n)

Краткое объяснение оценки временной сложности алгоритма соответственно представленной нотации Big(O):
Определение диапазона и бинарный поиск выполняются за логарифмическое время.
  
#### 6. Тернарный поиск (Трнарный поиск)

Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).

Объяснение работы алгоритма:
1. Делится диапазон индексов на три части.
2. Сравнивается искомый элемент с элементами на двух разделительных границах.
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трети
массива, где может находиться искомое значение.

Оценка временной сложности алгоритма в нотации Big(O):
O(log n)

Краткое объяснение оценки временной сложности алгоритма соответственно представленной нотации Big(O):
На каждой итерации диапазон уменьшается втрое, выполняется два сравнения, что даёт логарифмическую сложность.
